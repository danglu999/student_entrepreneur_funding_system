{"version":3,"file":"tether.min.js","sources":["../../src/js/utils/classes.js","../../src/js/utils/deferred.js","../../src/js/utils/general.js","../../src/js/utils/type-check.js","../../src/js/utils/bounds.js","../../src/js/abutment.js","../../src/js/constraint.js","../../src/js/shift.js","../../src/js/evented.js","../../src/js/utils/offset.js","../../src/js/utils/parents.js","../../src/js/tether.js"],"sourcesContent":["export function addClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.add(cls);\n    }\n  });\n}\n\nexport function removeClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.remove(cls);\n    }\n  });\n}\n\nexport function updateClasses(el, add, all) {\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\n  // 'add' classes to be set.\n  all.forEach((cls) => {\n    if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n      removeClass(el, cls);\n    }\n  });\n\n  add.forEach((cls) => {\n    if (!el.classList.contains(cls)) {\n      addClass(el, cls);\n    }\n  });\n}\n","const deferred = [];\n\nexport function defer(fn) {\n  deferred.push(fn);\n}\n\nexport function flush() {\n  let fn;\n  // eslint-disable-next-line\n  while (fn = deferred.pop()) {\n    fn();\n  }\n}\n","let _scrollBarSize = null;\n\nexport function extend(out = {}) {\n  const args = [];\n\n  Array.prototype.push.apply(args, arguments);\n\n  args.slice(1).forEach((obj) => {\n    if (obj) {\n      for (let key in obj) {\n        if ({}.hasOwnProperty.call(obj, key)) {\n          out[key] = obj[key];\n        }\n      }\n    }\n  });\n\n  return out;\n}\n\nexport function getScrollBarSize() {\n  if (_scrollBarSize) {\n    return _scrollBarSize;\n  }\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  extend(outer.style, {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    pointerEvents: 'none',\n    visibility: 'hidden',\n    width: '200px',\n    height: '150px',\n    overflow: 'hidden'\n  });\n\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n\n  const widthContained = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let widthScroll = inner.offsetWidth;\n\n  if (widthContained === widthScroll) {\n    widthScroll = outer.clientWidth;\n  }\n\n  document.body.removeChild(outer);\n\n  const width = widthContained - widthScroll;\n\n  _scrollBarSize = { width, height: width };\n  return _scrollBarSize;\n}\n\nexport const uniqueId = (() => {\n  let id = 0;\n  return () => ++id;\n})();\n","/**\n * Checks if `value` is classified as a `Function` object.\n * @param {*} value The param to check if it is a function\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `Number` object.\n * @param {*} value The param to check if it is a number\n */\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\n/**\n * Checks if `value` is classified as an `Object`.\n * @param {*} value The param to check if it is an object\n */\nexport function isObject(value) {\n  return typeof value === 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param {*} value The param to check if it is a string\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param {*} value The param to check if it is undefined\n */\nexport function isUndefined(value) {\n  return value === undefined;\n}\n","import { defer } from './deferred';\nimport { extend, uniqueId } from './general';\nimport { isUndefined } from './type-check';\n\nconst zeroPosCache = {};\nlet zeroElement = null;\n\nexport function getBounds(el) {\n  let doc;\n  if (el === document) {\n    doc = document;\n    el = document.documentElement;\n  } else {\n    doc = el.ownerDocument;\n  }\n\n  const docEl = doc.documentElement;\n\n  const box = _getActualBoundingClientRect(el);\n\n  const origin = _getOrigin();\n\n  box.top -= origin.top;\n  box.left -= origin.left;\n\n  if (isUndefined(box.width)) {\n    box.width = document.body.scrollWidth - box.left - box.right;\n  }\n  if (isUndefined(box.height)) {\n    box.height = document.body.scrollHeight - box.top - box.bottom;\n  }\n\n  box.top = box.top - docEl.clientTop;\n  box.left = box.left - docEl.clientLeft;\n  box.right = doc.body.clientWidth - box.width - box.left;\n  box.bottom = doc.body.clientHeight - box.height - box.top;\n\n  return box;\n}\n\nexport function removeUtilElements() {\n  if (zeroElement) {\n    document.body.removeChild(zeroElement);\n  }\n  zeroElement = null;\n}\n\n/**\n * Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n * if the element lies within a nested document (<frame> or <iframe>-like).\n * @param node\n */\nfunction _getActualBoundingClientRect(node) {\n  let boundingRect = node.getBoundingClientRect();\n\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n  let rect = {};\n  for (let k in boundingRect) {\n    rect[k] = boundingRect[k];\n  }\n\n  try {\n    if (node.ownerDocument !== document) {\n      let { frameElement } = node.ownerDocument.defaultView;\n      if (frameElement) {\n        let frameRect = _getActualBoundingClientRect(frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n  } catch(err) {\n    // Ignore \"Access is denied\" in IE11/Edge\n  }\n\n  return rect;\n}\n\nfunction _getOrigin() {\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n  // jitter as the user scrolls that messes with our ability to detect if two positions\n  // are equivilant or not.  We place an element at the top left of the page that will\n  // get the same jitter, so we can cancel the two out.\n  let node = zeroElement;\n  if (!node || !document.body.contains(node)) {\n    node = document.createElement('div');\n    node.setAttribute('data-tether-id', uniqueId());\n    extend(node.style, {\n      top: 0,\n      left: 0,\n      position: 'absolute'\n    });\n\n    document.body.appendChild(node);\n\n    zeroElement = node;\n  }\n\n  const id = node.getAttribute('data-tether-id');\n  if (isUndefined(zeroPosCache[id])) {\n    zeroPosCache[id] = _getActualBoundingClientRect(node);\n\n    // Clear the cache when this position call is done\n    defer(() => {\n      delete zeroPosCache[id];\n    });\n  }\n\n  return zeroPosCache[id];\n}\n","import { updateClasses } from './utils/classes';\nimport { defer } from './utils/deferred';\nimport { getBounds } from './utils/bounds';\n\nexport default {\n  position({ top, left }) {\n    const { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    const targetPos = this.getTargetBounds();\n\n    const bottom = top + height;\n    const right = left + width;\n\n    const abutted = [];\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\n      ['left', 'right'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === left || targetPosSide === right) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    if (left <= targetPos.right && right >= targetPos.left) {\n      ['top', 'bottom'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === top || targetPosSide === bottom) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    const sides = ['left', 'top', 'right', 'bottom'];\n    this.all.push(this.getClass('abutted'));\n    sides.forEach((side) => {\n      this.all.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    if (abutted.length) {\n      this.add.push(this.getClass('abutted'));\n    }\n\n    abutted.forEach((side) => {\n      this.add.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this.add, this.all);\n      }\n      updateClasses(this.element, this.add, this.all);\n    });\n\n    return true;\n  }\n};\n","import { updateClasses } from './utils/classes';\nimport { defer } from './utils/deferred';\nimport { extend } from './utils/general';\nimport { getBounds } from './utils/bounds';\nimport { isString, isUndefined } from './utils/type-check';\n\nconst BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\nfunction getBoundingRect(tether, to) {\n  if (to === 'scrollParent') {\n    to = tether.scrollParents[0];\n  } else if (to === 'window') {\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n  }\n\n  if (to === document) {\n    to = to.documentElement;\n  }\n\n  if (!isUndefined(to.nodeType)) {\n    const node = to;\n    const size = getBounds(to);\n    const pos = size;\n    const style = getComputedStyle(to);\n\n    to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n    // Account any parent Frames scroll offset\n    if (node.ownerDocument !== document) {\n      let win = node.ownerDocument.defaultView;\n      to[0] += win.pageXOffset;\n      to[1] += win.pageYOffset;\n      to[2] += win.pageXOffset;\n      to[3] += win.pageYOffset;\n    }\n\n    BOUNDS_FORMAT.forEach((side, i) => {\n      side = side[0].toUpperCase() + side.substr(1);\n      if (side === 'Top' || side === 'Left') {\n        to[i] += parseFloat(style[`border${side}Width`]);\n      } else {\n        to[i] -= parseFloat(style[`border${side}Width`]);\n      }\n    });\n  }\n\n  return to;\n}\n\nexport default {\n  position({ top, left, targetAttachment }) {\n    if (!this.options.constraints) {\n      return true;\n    }\n\n    let { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    if (width === 0 && height === 0 && !isUndefined(this.lastSize)) {\n      // Handle the item getting hidden as a result of our positioning without glitching\n      // the classes in and out\n      ({ width, height } = this.lastSize);\n    }\n\n    const targetSize = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n\n    const { height: targetHeight, width: targetWidth } = targetSize;\n\n    const allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n\n    this.options.constraints.forEach((constraint) => {\n      const { outOfBoundsClass, pinnedClass } = constraint;\n      if (outOfBoundsClass) {\n        allClasses.push(outOfBoundsClass);\n      }\n      if (pinnedClass) {\n        allClasses.push(pinnedClass);\n      }\n    });\n\n    allClasses.forEach((cls) => {\n      ['left', 'top', 'right', 'bottom'].forEach((side) => {\n        allClasses.push(`${cls}-${side}`);\n      });\n    });\n\n    const addClasses = [];\n\n    const tAttachment = extend({}, targetAttachment);\n    const eAttachment = extend({}, this.attachment);\n\n    this.options.constraints.forEach((constraint) => {\n      let { to, attachment, pin } = constraint;\n\n      if (isUndefined(attachment)) {\n        attachment = '';\n      }\n\n      let changeAttachX, changeAttachY;\n      if (attachment.indexOf(' ') >= 0) {\n        [changeAttachY, changeAttachX] = attachment.split(' ');\n      } else {\n        changeAttachX = changeAttachY = attachment;\n      }\n\n      const bounds = getBoundingRect(this, to);\n\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\n        if (top < bounds[1] && tAttachment.top === 'top') {\n          top += targetHeight;\n          tAttachment.top = 'bottom';\n        }\n\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n          top -= targetHeight;\n          tAttachment.top = 'top';\n        }\n      }\n\n      if (changeAttachY === 'together') {\n        if (tAttachment.top === 'top') {\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n\n            top += height;\n            eAttachment.top = 'top';\n\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n            top -= height - targetHeight;\n            tAttachment.top = 'bottom';\n\n            eAttachment.top = 'bottom';\n          }\n        }\n\n        if (tAttachment.top === 'bottom') {\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n            top += height - targetHeight;\n            tAttachment.top = 'top';\n\n            eAttachment.top = 'top';\n\n          }\n        }\n\n        if (tAttachment.top === 'middle') {\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n        }\n      }\n\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          left += targetWidth;\n          tAttachment.left = 'right';\n        }\n\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\n          left -= targetWidth;\n          tAttachment.left = 'left';\n        }\n      }\n\n      if (changeAttachX === 'together') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          if (eAttachment.left === 'right') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left += width;\n            eAttachment.left = 'left';\n\n          } else if (eAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left -= width;\n            eAttachment.left = 'right';\n          }\n\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n          if (eAttachment.left === 'left') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (eAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left += width;\n            eAttachment.left = 'left';\n          }\n\n        } else if (tAttachment.left === 'center') {\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          }\n        }\n      }\n\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\n          top += height;\n          eAttachment.top = 'top';\n        }\n\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\n          top -= height;\n          eAttachment.top = 'bottom';\n        }\n      }\n\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\n        if (left < bounds[0]) {\n          if (eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          } else if (eAttachment.left === 'center') {\n            left += (width / 2);\n            eAttachment.left = 'left';\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n          } else if (eAttachment.left === 'center') {\n            left -= (width / 2);\n            eAttachment.left = 'right';\n          }\n        }\n      }\n\n      if (isString(pin)) {\n        pin = pin.split(',').map((p) => p.trim());\n      } else if (pin === true) {\n        pin = ['top', 'left', 'right', 'bottom'];\n      }\n\n      pin = pin || [];\n\n      const pinned = [];\n      const oob = [];\n\n      if (top < bounds[1]) {\n        if (pin.indexOf('top') >= 0) {\n          top = bounds[1];\n          pinned.push('top');\n        } else {\n          oob.push('top');\n        }\n      }\n\n      if (top + height > bounds[3]) {\n        if (pin.indexOf('bottom') >= 0) {\n          top = bounds[3] - height;\n          pinned.push('bottom');\n        } else {\n          oob.push('bottom');\n        }\n      }\n\n      if (left < bounds[0]) {\n        if (pin.indexOf('left') >= 0) {\n          left = bounds[0];\n          pinned.push('left');\n        } else {\n          oob.push('left');\n        }\n      }\n\n      if (left + width > bounds[2]) {\n        if (pin.indexOf('right') >= 0) {\n          left = bounds[2] - width;\n          pinned.push('right');\n        } else {\n          oob.push('right');\n        }\n      }\n\n      if (pinned.length) {\n        let pinnedClass;\n        if (!isUndefined(this.options.pinnedClass)) {\n          pinnedClass = this.options.pinnedClass;\n        } else {\n          pinnedClass = this.getClass('pinned');\n        }\n\n        addClasses.push(pinnedClass);\n        pinned.forEach((side) => {\n          addClasses.push(`${pinnedClass}-${side}`);\n        });\n      }\n\n      if (oob.length) {\n        let oobClass;\n        if (!isUndefined(this.options.outOfBoundsClass)) {\n          oobClass = this.options.outOfBoundsClass;\n        } else {\n          oobClass = this.getClass('out-of-bounds');\n        }\n\n        addClasses.push(oobClass);\n        oob.forEach((side) => {\n          addClasses.push(`${oobClass}-${side}`);\n        });\n      }\n\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n        eAttachment.left = tAttachment.left = false;\n      }\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n        eAttachment.top = tAttachment.top = false;\n      }\n\n      if (tAttachment.top !== targetAttachment.top ||\n        tAttachment.left !== targetAttachment.left ||\n        eAttachment.top !== this.attachment.top ||\n        eAttachment.left !== this.attachment.left) {\n        this.updateAttachClasses(eAttachment, tAttachment);\n        this.trigger('update', {\n          attachment: eAttachment,\n          targetAttachment: tAttachment\n        });\n      }\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return { top, left };\n  }\n};\n","import { isFunction, isString } from './utils/type-check';\n\nexport default {\n  position({ top, left }) {\n    if (!this.options.shift) {\n      return;\n    }\n\n    let { shift } = this.options;\n    if (isFunction(shift)) {\n      shift = shift.call(this, { top, left });\n    }\n\n    let shiftTop, shiftLeft;\n    if (isString(shift)) {\n      shift = shift.split(' ');\n      shift[1] = shift[1] || shift[0];\n\n      ([shiftTop, shiftLeft] = shift);\n\n      shiftTop = parseFloat(shiftTop, 10);\n      shiftLeft = parseFloat(shiftLeft, 10);\n    } else {\n      ([shiftTop, shiftLeft] = [shift.top, shift.left]);\n    }\n\n    top += shiftTop;\n    left += shiftLeft;\n\n    return { top, left };\n  }\n};\n","import { isUndefined } from './utils/type-check';\n\nexport class Evented {\n  on(event, handler, ctx, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (isUndefined(this.bindings) ||\n      isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        if (this.bindings[event][i].handler === handler) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        const { handler, ctx, once } = this.bindings[event][i];\n\n        let context = ctx;\n        if (isUndefined(context)) {\n          context = this;\n        }\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","import { isString, isUndefined } from './type-check';\n\nconst MIRROR_LR = {\n  center: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nconst MIRROR_TB = {\n  middle: 'middle',\n  top: 'bottom',\n  bottom: 'top'\n};\n\nconst OFFSET_MAP = {\n  top: 0,\n  left: 0,\n  middle: '50%',\n  center: '50%',\n  bottom: '100%',\n  right: '100%'\n};\n\nexport function addOffset(...offsets) {\n  const out = { top: 0, left: 0 };\n\n  offsets.forEach(({ top, left }) => {\n    if (isString(top)) {\n      top = parseFloat(top);\n    }\n    if (isString(left)) {\n      left = parseFloat(left);\n    }\n\n    out.top += top;\n    out.left += left;\n  });\n\n  return out;\n}\n\nexport function attachmentToOffset(attachment) {\n  let { left, top } = attachment;\n\n  if (!isUndefined(OFFSET_MAP[attachment.left])) {\n    left = OFFSET_MAP[attachment.left];\n  }\n\n  if (!isUndefined(OFFSET_MAP[attachment.top])) {\n    top = OFFSET_MAP[attachment.top];\n  }\n\n  return { left, top };\n}\n\nexport function autoToFixedAttachment(attachment, relativeToAttachment) {\n  let { left, top } = attachment;\n\n  if (left === 'auto') {\n    left = MIRROR_LR[relativeToAttachment.left];\n  }\n\n  if (top === 'auto') {\n    top = MIRROR_TB[relativeToAttachment.top];\n  }\n\n  return { left, top };\n}\n\nexport function offsetToPx(offset, size) {\n  if (isString(offset.left) && offset.left.indexOf('%') !== -1) {\n    offset.left = parseFloat(offset.left) / 100 * size.width;\n  }\n  if (isString(offset.top) && offset.top.indexOf('%') !== -1) {\n    offset.top = parseFloat(offset.top) / 100 * size.height;\n  }\n\n  return offset;\n}\n\nexport function parseTopLeft(value) {\n  const [top, left] = value.split(' ');\n  return { top, left };\n}\n","import { isUndefined } from './type-check';\n\nexport function getScrollParents(el) {\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  const computedStyle = getComputedStyle(el) || {};\n  const { position } = computedStyle;\n  let parents = [];\n\n  if (position === 'fixed') {\n    return [el];\n  }\n\n  let parent = el;\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n    let style;\n    try {\n      style = getComputedStyle(parent);\n    } catch(err) {\n      // Intentionally blank\n    }\n\n    if (isUndefined(style) || style === null) {\n      parents.push(parent);\n      return parents;\n    }\n\n    const { overflow, overflowX, overflowY } = style;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n        parents.push(parent);\n      }\n    }\n  }\n\n  parents.push(el.ownerDocument.body);\n\n  // If the node is within a frame, account for the parent window scroll\n  if (el.ownerDocument !== document) {\n    parents.push(el.ownerDocument.defaultView);\n  }\n\n  return parents;\n}\n\nexport function getOffsetParent(el) {\n  return el.offsetParent || document.documentElement;\n}\n","import '../css/tether.scss';\nimport '../css/tether-theme-arrows.scss';\nimport '../css/tether-theme-arrows-dark.scss';\nimport '../css/tether-theme-basic.scss';\nimport Abutment from './abutment';\nimport Constraint from './constraint';\nimport Shift from './shift';\nimport { Evented } from './evented';\nimport { addClass, removeClass, updateClasses } from './utils/classes';\nimport { defer, flush } from './utils/deferred';\nimport { extend, getScrollBarSize } from './utils/general';\nimport { addOffset, attachmentToOffset, autoToFixedAttachment, offsetToPx, parseTopLeft } from './utils/offset';\nimport { getBounds, removeUtilElements } from './utils/bounds';\nimport { getOffsetParent, getScrollParents } from './utils/parents';\nimport { isNumber, isObject, isString, isUndefined } from './utils/type-check';\n\nconst TetherBase = { modules: [Constraint, Abutment, Shift] };\n\nfunction isFullscreenElement(e) {\n  let d = e.ownerDocument;\n  let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n  return fe === e;\n}\n\nfunction within(a, b, diff = 1) {\n  return (a + diff >= b && b >= a - diff);\n}\n\nconst transformKey = (() => {\n  if (isUndefined(document)) {\n    return '';\n  }\n  const el = document.createElement('div');\n\n  const transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n  for (let i = 0; i < transforms.length; ++i) {\n    const key = transforms[i];\n    if (el.style[key] !== undefined) {\n      return key;\n    }\n  }\n})();\n\nconst tethers = [];\n\nconst position = () => {\n  tethers.forEach((tether) => {\n    tether.position(false);\n  });\n  flush();\n};\n\nfunction now() {\n  return performance.now();\n}\n\n(() => {\n  let lastCall = null;\n  let lastDuration = null;\n  let pendingTimeout = null;\n\n  const tick = () => {\n    if (!isUndefined(lastDuration) && lastDuration > 16) {\n      // We voluntarily throttle ourselves if we can't manage 60fps\n      lastDuration = Math.min(lastDuration - 16, 250);\n\n      // Just in case this is the last event, remember to position just once more\n      pendingTimeout = setTimeout(tick, 250);\n      return;\n    }\n\n    if (!isUndefined(lastCall) && (now() - lastCall) < 10) {\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\n      return;\n    }\n\n    if (pendingTimeout != null) {\n      clearTimeout(pendingTimeout);\n      pendingTimeout = null;\n    }\n\n    lastCall = now();\n    position();\n    lastDuration = now() - lastCall;\n  };\n\n  if (!isUndefined(window) && !isUndefined(window.addEventListener)) {\n    ['resize', 'scroll', 'touchmove'].forEach((event) => {\n      window.addEventListener(event, tick);\n    });\n  }\n})();\n\nclass TetherClass extends Evented {\n  constructor(options) {\n    super();\n    this.position = this.position.bind(this);\n\n    tethers.push(this);\n\n    this.history = [];\n\n    this.setOptions(options, false);\n\n    TetherBase.modules.forEach((module) => {\n      if (!isUndefined(module.initialize)) {\n        module.initialize.call(this);\n      }\n    });\n\n    this.position();\n  }\n\n  getClass(key = '') {\n    const { classes } = this.options;\n    if (!isUndefined(classes) && !isUndefined(classes[key])) {\n      if (classes[key] === false) {\n        return '';\n      }\n      return this.options.classes[key];\n    } else if (this.options.classPrefix) {\n      return `${this.options.classPrefix}-${key}`;\n    } else {\n      return key;\n    }\n  }\n\n  setOptions(options, pos = true) {\n    const defaults = {\n      offset: '0 0',\n      targetOffset: '0 0',\n      targetAttachment: 'auto auto',\n      classPrefix: 'tether'\n    };\n\n    this.options = extend(defaults, options);\n\n    let { element, target, targetModifier } = this.options;\n    this.element = element;\n    this.target = target;\n    this.targetModifier = targetModifier;\n\n    if (this.target === 'viewport') {\n      this.target = document.body;\n      this.targetModifier = 'visible';\n    } else if (this.target === 'scroll-handle') {\n      this.target = document.body;\n      this.targetModifier = 'scroll-handle';\n    }\n\n    ['element', 'target'].forEach((key) => {\n      if (isUndefined(this[key])) {\n        throw new Error('Tether Error: Both element and target must be defined');\n      }\n\n      if (!isUndefined(this[key].jquery)) {\n        this[key] = this[key][0];\n      } else if (isString(this[key])) {\n        this[key] = document.querySelector(this[key]);\n      }\n    });\n\n    this._addClasses();\n\n    if (!this.options.attachment) {\n      throw new Error('Tether Error: You must provide an attachment');\n    }\n\n    this.targetAttachment = parseTopLeft(this.options.targetAttachment);\n    this.attachment = parseTopLeft(this.options.attachment);\n    this.offset = parseTopLeft(this.options.offset);\n    this.targetOffset = parseTopLeft(this.options.targetOffset);\n\n    if (!isUndefined(this.scrollParents)) {\n      this.disable();\n    }\n\n    if (this.targetModifier === 'scroll-handle') {\n      this.scrollParents = [this.target];\n    } else {\n      this.scrollParents = getScrollParents(this.target);\n    }\n\n    if (!(this.options.enabled === false)) {\n      this.enable(pos);\n    }\n  }\n\n  getTargetBounds() {\n    if (!isUndefined(this.targetModifier)) {\n      if (this.targetModifier === 'visible') {\n        if (this.target === document.body) {\n          return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n        } else {\n          const bounds = getBounds(this.target);\n\n          const out = {\n            height: bounds.height,\n            width: bounds.width,\n            top: bounds.top,\n            left: bounds.left\n          };\n\n          out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n          out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));\n          out.height = Math.min(innerHeight, out.height);\n          out.height -= 2;\n\n          out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n          out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));\n          out.width = Math.min(innerWidth, out.width);\n          out.width -= 2;\n\n          if (out.top < pageYOffset) {\n            out.top = pageYOffset;\n          }\n          if (out.left < pageXOffset) {\n            out.left = pageXOffset;\n          }\n\n          return out;\n        }\n      } else if (this.targetModifier === 'scroll-handle') {\n        let bounds;\n        let { target } = this;\n        if (target === document.body) {\n          target = document.documentElement;\n\n          bounds = {\n            left: pageXOffset,\n            top: pageYOffset,\n            height: innerHeight,\n            width: innerWidth\n          };\n        } else {\n          bounds = getBounds(target);\n        }\n\n        const style = getComputedStyle(target);\n\n        const hasBottomScroll = (\n          target.scrollWidth > target.clientWidth ||\n          [style.overflow, style.overflowX].indexOf('scroll') >= 0 ||\n          this.target !== document.body\n        );\n\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n          scrollBottom = 15;\n        }\n\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n        const out = {\n          width: 15,\n          height: height * 0.975 * (height / target.scrollHeight),\n          left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n\n        let fitAdj = 0;\n        if (height < 408 && this.target === document.body) {\n          fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n\n        if (this.target !== document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        const scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n        if (this.target === document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        return out;\n      }\n    } else {\n      return getBounds(this.target);\n    }\n  }\n\n  clearCache() {\n    this._cache = {};\n  }\n\n  cache(k, getter) {\n    // More than one module will often need the same DOM info, so\n    // we keep a cache which is cleared on each position call\n    if (isUndefined(this._cache)) {\n      this._cache = {};\n    }\n\n    if (isUndefined(this._cache[k])) {\n      this._cache[k] = getter.call(this);\n    }\n\n    return this._cache[k];\n  }\n\n  enable(pos = true) {\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('enabled'));\n    }\n    addClass(this.element, this.getClass('enabled'));\n    this.enabled = true;\n\n    this.scrollParents.forEach((parent) => {\n      if (parent !== this.target.ownerDocument) {\n        parent.addEventListener('scroll', this.position);\n      }\n    });\n\n    if (pos) {\n      this.position();\n    }\n  }\n\n  disable() {\n    removeClass(this.target, this.getClass('enabled'));\n    removeClass(this.element, this.getClass('enabled'));\n    this.enabled = false;\n\n    if (!isUndefined(this.scrollParents)) {\n      this.scrollParents.forEach((parent) => {\n        parent.removeEventListener('scroll', this.position);\n      });\n    }\n  }\n\n  destroy() {\n    this.disable();\n\n    this._removeClasses();\n\n    tethers.forEach((tether, i) => {\n      if (tether === this) {\n        tethers.splice(i, 1);\n      }\n    });\n\n    // Remove any elements we were using for convenience from the DOM\n    if (tethers.length === 0) {\n      removeUtilElements();\n    }\n  }\n\n  updateAttachClasses(elementAttach, targetAttach) {\n    elementAttach = elementAttach || this.attachment;\n    targetAttach = targetAttach || this.targetAttachment;\n    const sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n\n    if (!isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n      // updateAttachClasses can be called more than once in a position call, so\n      // we need to clean up after ourselves such that when the last defer gets\n      // ran it doesn't add any extra classes from previous calls.\n      this._addAttachClasses.splice(0, this._addAttachClasses.length);\n    }\n\n    if (isUndefined(this._addAttachClasses)) {\n      this._addAttachClasses = [];\n    }\n    this.add = this._addAttachClasses;\n\n    if (elementAttach.top) {\n      this.add.push(`${this.getClass('element-attached')}-${elementAttach.top}`);\n    }\n    if (elementAttach.left) {\n      this.add.push(`${this.getClass('element-attached')}-${elementAttach.left}`);\n    }\n    if (targetAttach.top) {\n      this.add.push(`${this.getClass('target-attached')}-${targetAttach.top}`);\n    }\n    if (targetAttach.left) {\n      this.add.push(`${this.getClass('target-attached')}-${targetAttach.left}`);\n    }\n\n    this.all = [];\n    sides.forEach((side) => {\n      this.all.push(`${this.getClass('element-attached')}-${side}`);\n      this.all.push(`${this.getClass('target-attached')}-${side}`);\n    });\n\n    defer(() => {\n      if (isUndefined(this._addAttachClasses)) {\n        return;\n      }\n\n      updateClasses(this.element, this._addAttachClasses, this.all);\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this._addAttachClasses, this.all);\n      }\n\n      delete this._addAttachClasses;\n    });\n  }\n\n  position(flushChanges = true) {\n    // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n    // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.clearCache();\n\n    // Turn 'auto' attachments into the appropriate corner or edge\n    const targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n    this.updateAttachClasses(this.attachment, targetAttachment);\n\n    const elementPos = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    let { width, height } = elementPos;\n\n    if (width === 0 && height === 0 && !isUndefined(this.lastSize)) {\n      // We cache the height and width to make it possible to position elements that are\n      // getting hidden.\n      ({ width, height } = this.lastSize);\n    } else {\n      this.lastSize = { width, height };\n    }\n\n    const targetPos = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n    const targetSize = targetPos;\n\n    // Get an actual px offset from the attachment\n    let offset = offsetToPx(attachmentToOffset(this.attachment), { width, height });\n    let targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n    const manualOffset = offsetToPx(this.offset, { width, height });\n    const manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n    // Add the manually provided offset\n    offset = addOffset(offset, manualOffset);\n    targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n    // It's now our goal to make (element position + offset) == (target position + target offset)\n    let left = targetPos.left + targetOffset.left - offset.left;\n    let top = targetPos.top + targetOffset.top - offset.top;\n\n    for (let i = 0; i < TetherBase.modules.length; ++i) {\n      const module = TetherBase.modules[i];\n      const ret = module.position.call(this, {\n        left,\n        top,\n        targetAttachment,\n        targetPos,\n        elementPos,\n        offset,\n        targetOffset,\n        manualOffset,\n        manualTargetOffset,\n        scrollbarSize,\n        attachment: this.attachment\n      });\n\n      if (ret === false) {\n        return false;\n      } else if (isUndefined(ret) || !isObject(ret)) {\n        continue;\n      } else {\n        ({ top, left } = ret);\n      }\n    }\n\n    // We describe the position three different ways to give the optimizer\n    // a chance to decide the best possible way to position the element\n    // with the fewest repaints.\n    const next = {\n      // It's position relative to the page (absolute positioning when\n      // the element is a child of the body)\n      page: {\n        top,\n        left\n      },\n\n      // It's position relative to the viewport (fixed positioning)\n      viewport: {\n        top: top - pageYOffset,\n        bottom: pageYOffset - top - height + innerHeight,\n        left: left - pageXOffset,\n        right: pageXOffset - left - width + innerWidth\n      }\n    };\n\n    let doc = this.target.ownerDocument;\n    let win = doc.defaultView;\n\n    let scrollbarSize;\n    if (win.innerHeight > doc.documentElement.clientHeight) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.bottom -= scrollbarSize.height;\n    }\n\n    if (win.innerWidth > doc.documentElement.clientWidth) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.right -= scrollbarSize.width;\n    }\n\n    if (['', 'static'].indexOf(doc.body.style.position) === -1 ||\n      ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n      // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n      next.page.bottom = doc.body.scrollHeight - top - height;\n      next.page.right = doc.body.scrollWidth - left - width;\n    }\n\n    if (!isUndefined(this.options.optimizations) &&\n      this.options.optimizations.moveElement !== false &&\n      isUndefined(this.targetModifier)) {\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n      const offsetPosition = this.cache('target-offsetparent-bounds', () => getBounds(offsetParent));\n      const offsetParentStyle = getComputedStyle(offsetParent);\n      const offsetParentSize = offsetPosition;\n\n      const offsetBorder = {};\n      ['Top', 'Left', 'Bottom', 'Right'].forEach((side) => {\n        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${side}Width`]);\n      });\n\n      offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n      offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n      if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {\n        if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {\n          // We're within the visible part of the target's scroll parent\n          const { scrollLeft, scrollTop } = offsetParent;\n\n          // It's position relative to the target's offset parent (absolute positioning when\n          // the element is moved to be a child of the target's offset parent).\n          next.offset = {\n            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n          };\n        }\n      }\n    }\n\n    // We could also travel up the DOM and try each containing context, rather than only\n    // looking at the body, but we're gonna get diminishing returns.\n\n    this.move(next);\n\n    this.history.unshift(next);\n\n    if (this.history.length > 3) {\n      this.history.pop();\n    }\n\n    if (flushChanges) {\n      flush();\n    }\n\n    return true;\n  }\n\n  // THE ISSUE\n  move(pos) {\n    if (isUndefined(this.element.parentNode)) {\n      return;\n    }\n\n    const same = {};\n\n    for (let type in pos) {\n      same[type] = {};\n\n      for (let key in pos[type]) {\n        let found = false;\n\n        for (let i = 0; i < this.history.length; ++i) {\n          const point = this.history[i];\n          if (!isUndefined(point[type]) &&\n            !within(point[type][key], pos[type][key])) {\n            found = true;\n            break;\n          }\n\n        }\n\n        if (!found) {\n          same[type][key] = true;\n        }\n      }\n    }\n\n    let css = { top: '', left: '', right: '', bottom: '' };\n\n    const transcribe = (_same, _pos) => {\n      const hasOptimizations = !isUndefined(this.options.optimizations);\n      const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n      if (gpu !== false) {\n        let yPos, xPos;\n        if (_same.top) {\n          css.top = 0;\n          yPos = _pos.top;\n        } else {\n          css.bottom = 0;\n          yPos = -_pos.bottom;\n        }\n\n        if (_same.left) {\n          css.left = 0;\n          xPos = _pos.left;\n        } else {\n          css.right = 0;\n          xPos = -_pos.right;\n        }\n\n        if (isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n          xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n          yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n        }\n\n        css[transformKey] = `translateX(${xPos}px) translateY(${yPos}px)`;\n\n        if (transformKey !== 'msTransform') {\n          // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n          // but IE9 doesn't support 3d transforms and will choke.\n          css[transformKey] += ' translateZ(0)';\n        }\n\n      } else {\n        if (_same.top) {\n          css.top = `${_pos.top}px`;\n        } else {\n          css.bottom = `${_pos.bottom}px`;\n        }\n\n        if (_same.left) {\n          css.left = `${_pos.left}px`;\n        } else {\n          css.right = `${_pos.right}px`;\n        }\n      }\n    };\n\n    const hasOptimizations = !isUndefined(this.options.optimizations);\n    let allowPositionFixed = true;\n\n    if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n      allowPositionFixed = false;\n    }\n\n    let moved = false;\n    if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n      css.position = 'absolute';\n      transcribe(same.page, pos.page);\n\n    } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n      css.position = 'fixed';\n      transcribe(same.viewport, pos.viewport);\n    } else if (!isUndefined(same.offset) && same.offset.top && same.offset.left) {\n      css.position = 'absolute';\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n\n      if (getOffsetParent(this.element) !== offsetParent) {\n        defer(() => {\n          this.element.parentNode.removeChild(this.element);\n          offsetParent.appendChild(this.element);\n        });\n      }\n\n      transcribe(same.offset, pos.offset);\n      moved = true;\n\n    } else {\n      css.position = 'absolute';\n      transcribe({ top: true, left: true }, pos.page);\n    }\n\n    if (!moved) {\n      if (this.options.bodyElement) {\n        if (this.element.parentNode !== this.options.bodyElement) {\n          this.options.bodyElement.appendChild(this.element);\n        }\n      } else {\n        let offsetParentIsBody = true;\n\n        let currentNode = this.element.parentNode;\n        while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n          if (getComputedStyle(currentNode).position !== 'static') {\n            offsetParentIsBody = false;\n            break;\n          }\n\n          currentNode = currentNode.parentNode;\n        }\n\n        if (!offsetParentIsBody) {\n          this.element.parentNode.removeChild(this.element);\n          this.element.ownerDocument.body.appendChild(this.element);\n        }\n      }\n    }\n\n    // Any css change will trigger a repaint, so let's avoid one if nothing changed\n    const writeCSS = {};\n    let write = false;\n    for (let key in css) {\n      let val = css[key];\n      let elVal = this.element.style[key];\n\n      if (elVal !== val) {\n        write = true;\n        writeCSS[key] = val;\n      }\n    }\n\n    if (write) {\n      defer(() => {\n        extend(this.element.style, writeCSS);\n        this.trigger('repositioned');\n      });\n    }\n  }\n\n  _addClasses() {\n    addClass(this.element, this.getClass('element'));\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('target'));\n    }\n  }\n\n  _removeClasses() {\n    removeClass(this.element, this.getClass('element'));\n    if (!(this.options.addTargetClasses === false)) {\n      removeClass(this.target, this.getClass('target'));\n    }\n\n    this.all.forEach((className) => {\n      this.element.classList.remove(className);\n      this.target.classList.remove(className);\n    });\n  }\n}\n\nTetherClass.modules = [];\n\nTetherBase.position = position;\n\nlet Tether = extend(TetherClass, TetherBase);\n\nTether.modules.push({\n  initialize() {\n    this.markers = {};\n\n    ['target', 'element'].forEach((type) => {\n      const el = document.createElement('div');\n      el.className = this.getClass(`${type}-marker`);\n\n      const dot = document.createElement('div');\n      dot.className = this.getClass('marker-dot');\n      el.appendChild(dot);\n\n      this[type].appendChild(el);\n\n      this.markers[type] = { dot, el };\n    });\n  },\n\n  position({ manualOffset, manualTargetOffset }) {\n    const offsets = {\n      element: manualOffset,\n      target: manualTargetOffset\n    };\n\n    for (let type in offsets) {\n      const offset = offsets[type];\n      for (let side in offset) {\n        let val = offset[side];\n        if (!isString(val) ||\n          val.indexOf('%') === -1 &&\n          val.indexOf('px') === -1) {\n          val += 'px';\n        }\n\n        if (this.markers[type].dot.style[side] !== val) {\n          this.markers[type].dot.style[side] = val;\n        }\n      }\n    }\n\n    return true;\n  }\n});\n\nexport default Tether;\n"],"names":["addClass","el","name","split","forEach","cls","trim","classList","add","removeClass","remove","updateClasses","all","indexOf","contains","deferred","defer","fn","push","flush","pop","_scrollBarSize","extend","out","args","Array","prototype","apply","arguments","slice","obj","key","hasOwnProperty","call","getScrollBarSize","inner","document","createElement","style","width","height","outer","position","top","left","pointerEvents","visibility","overflow","appendChild","body","widthContained","offsetWidth","widthScroll","clientWidth","removeChild","id","uniqueId","isString","value","isUndefined","undefined","zeroPosCache","zeroElement","getBounds","doc","documentElement","ownerDocument","docEl","box","_getActualBoundingClientRect","origin","node","setAttribute","getAttribute","_getOrigin","scrollWidth","right","scrollHeight","bottom","clientTop","clientLeft","clientHeight","boundingRect","getBoundingClientRect","rect","k","frameElement","defaultView","frameRect","err","this","cache","_this","element","targetPos","getTargetBounds","abutted","side","targetPosSide","getClass","length","options","addTargetClasses","target","BOUNDS_FORMAT","targetAttachment","constraints","lastSize","targetSize","targetHeight","targetWidth","allClasses","constraint","outOfBoundsClass","pinnedClass","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","to","pin","bounds","tether","scrollParents","pageXOffset","pageYOffset","innerWidth","innerHeight","nodeType","size","pos","getComputedStyle","win","i","toUpperCase","substr","parseFloat","getBoundingRect","map","p","oobClass","pinned","oob","updateAttachClasses","trigger","shift","shiftTop","shiftLeft","Evented","on","event","handler","ctx","once","bindings","off","splice","context","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","addOffset","offsets","attachmentToOffset","offsetToPx","offset","parseTopLeft","getOffsetParent","offsetParent","TetherBase","modules","Constraint","Abutment","Shift","lastCall","lastDuration","pendingTimeout","tick","transformKey","transforms","tethers","now","performance","Math","min","setTimeout","clearTimeout","window","addEventListener","TetherClass","bind","history","setOptions","module","initialize","classes","classPrefix","targetOffset","targetModifier","_this2","Error","jquery","querySelector","_addClasses","disable","parents","parent","parentNode","overflowX","overflowY","test","getScrollParents","enabled","enable","scrollBottom","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","pow","max","scrollPercentage","scrollTop","clearCache","_cache","getter","_this3","removeEventListener","_this4","destroy","_removeClasses","_this5","elementAttach","targetAttach","_addAttachClasses","_this6","flushChanges","relativeToAttachment","autoToFixedAttachment","elementPos","_this7","manualOffset","manualTargetOffset","ret","scrollbarSize","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","a","b","diff","same","type","found","point","within","css","transcribe","_same","_pos","yPos","xPos","_this8","gpu","devicePixelRatio","round","allowPositionFixed","e","d","moved","bodyElement","offsetParentIsBody","currentNode","tagName","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","writeCSS","write","val","className","_this9","Tether","markers","_this10","dot"],"mappings":"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"}